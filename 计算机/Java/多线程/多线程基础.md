# 进程和线程

> 毕向东 - Java 基础视频

## 进程

一个正在执行中的程序。

每个进程都有一个执行顺序，该顺序是一个执行路径（执行情景），或者叫一个执行单元。

进程用于标识系统分配的内存空间，封装控制单元。

> 补充概念
>
> [进程的基本概念](https://www.cnblogs.com/mlgjb/p/8241718.html)

- 进程是一个具有一定独立功能的**程序**关于某个**数据集合**的一次**运行**活动，是系统进行**资源分配**和**调度运行**的基本单位。

- 程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念，无法反应系统运行时的并行特性。

  例如：两个C语言源程序由一个编译程序完成编译，若用程序概念理解，内存中只有一个编译程序运行（两个源程序看作编译程序的输入数据），但是这样无法说明白内存中运行着两个任务。程序的概念不能表示这种并行情况，反映不了他们活动的规律和状态变化。就像不能用菜谱（程序）代替炒菜（程序执行的过程）一样（这句话我稍微修改了一下，感觉应该是这样表诉才对）。

## 线程

线程就是进程中的一个控制单元，线程控制着进程的执行。

一个进程中至少有一个线程。

JVM启动的时候会有一个进程java.exe，该进程中至少一个进程负责java程序的执行，而且这个线程运行的代码存在于main方法中，该线程称之为主线程。

更细节的说明 jvm ：即使只有主线程的Java程序中， jvm 中也不止一个线程，还有负责垃圾回收机制的线程。

## 进行和线程的对比

> [进程和线程的区别](https://blog.csdn.net/wsq119/article/details/82154305)
>
> [进程和线程的区别介绍](https://baijiahao.baidu.com/s?id=1611925141861592999&wfr=spider&for=pc)
>
> [进程和线程的选择](https://www.cnblogs.com/aaronthon/p/9824396.html)

1. **进程**是**资源分配**最小单位，**线程**是程序**执行**的最小单位；

2. 在多线程OS中，进程不是一个可执行的实体。

2. **进程有自己独立的地址空间**，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，**线程没有**独立的地址空间，它使用相同的地址空间共享数据。

   **线程**上下文只包含**一个堆栈、一个寄存器、一个优先权**，线程文本包含在他的进程 的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。 同一进程中的多个**线程共享代码段**(代码和常量)，**数据段**(全局变量和静态变量)，**扩展段**(堆存储)。但是每个线程拥有自己的栈段， 寄存器的内容，**栈段**又叫运行时段，用来存放所有**局部变量和临时变量**。
   
4. 进程对**资源保护**要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；

5. 多进程程序更**安全**，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；

6. **CPU切换**一个线程比切换进程花费小；

7. **创建**一个线程比进程开销小；

7. 线程占用的**资源**要⽐进程少很多。

8. 线程之间**通信**更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）

> 更多参考
>
> [程序、进程和线程](https://www.cnblogs.com/fengff/p/9622026.html)
>
> [知乎 - 线程和进程的区别是什么？](https://www.zhihu.com/question/25532384?sort=created)
>
> [进程和线程的通信](https://www.jianshu.com/p/00bd894ff86c)

# 线程的创建

## 继承 Thread 类

1. 定义类继承 Thread 类

2. 重写 Thread 类 run() 方法。目的：将自定义代码存放在 run() 方法中，让线程执行。

   ```java
   class PrimeThread extends Thread {
            long minPrime;
            PrimeThread(long minPrime) {
                this.minPrime = minPrime;
            }
   
            public void run() {
                // compute primes larger than minPrime
                 . . .
            }
        }
   ```
   
3. 调用线程类的 start() 方法
   
   ```java
   PrimeRun p = new PrimeRun(143); // 创建线程
   new Thread(p).start(); //启动线程，调用 run() 方法
   ```

**说明**

- 多个线程都会获取 CPU 的执行权。CPU 执行到谁，谁就运行。

- 在某一时刻一个 CPU 核心只有一个线程在运行，CPU 进行快速的切换，以达到看起来是同时运行的效果。

- 可将多线程的运行形容为在互相抢夺 CPU 的执行权。

- 多线程的一个特点是“随机性”。谁抢到谁执行，执行时间由 CPU 决定。

- run() 方法就是 Thread 类留给使用者存储自定义功能代码的地方。

  Thread 类用于描述线程，目的是方便使用者创建另外的线程来执行自定义功能。 复杂的线程创建和启动等操作由 Thread 类实现好，子类覆盖 run() 方法实现自定义功能，通过运行时多态的特性，完成线程基本功能和自定义功能的有机结合。

- run() 并不会开启线程， start() 方法才会去执行开启线程的操作。

  创建好线程类的对象，仅创建了线程，如果直接用线程对象调用 run() 方法，不会开启新线程来执行自定义代码，而是直接在原有线程中顺序执行 run() 方法及其之后内容，无法达到原线程和新线程并发执行的效果。

## 实现 Runnable 接口